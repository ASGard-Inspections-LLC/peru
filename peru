#! /usr/bin/env python3

import sys
import os
from os import path
import subprocess
import tempfile
from urllib import parse
import shutil

if not path.isfile("peru"):
    print("No peru file found.")
    sys.exit(1)

def git(git_dir, *args):
    assert git_dir == None or path.isdir(git_dir)
    command = ["git"]
    if git_dir:
        command.append("--git-dir=" + git_dir)
    command.extend(args)
    return subprocess.check_output(command, stderr=subprocess.STDOUT,
                                   universal_newlines=True)

def git_clone_cached(src):
    escaped = parse.quote(src, safe="")
    # Use $PERU_CACHE_NAME if defined, otherwise use the default root path.
    root_path = os.getenv("PERU_CACHE_NAME") or ".peru-cache"
    cached_path = path.join(root_path, "git", escaped)
    if not path.exists(cached_path):
        try:
            print("cloning...")
            os.makedirs(cached_path)
            git(None, "clone", "--mirror", src, cached_path)
        except:
            # Delete the whole thing if the clone failed, to avoid confusing
            # the cache.
            shutil.rmtree(cached_path)
            raise
    return cached_path

def populate_git_module(src, dest, version):
    cached_dir = git_clone_cached(src)
    os.makedirs(dest, exist_ok=True)
    # TODO: Eventually avoid this fetch by caching outputs.
    print("fetching...")
    git(cached_dir, "fetch", "--prune")
    # Checkout the specified revision from the clone into the dest dir.
    git(cached_dir, "--work-tree=" + dest, "checkout", version, "--", ".")

def git_module(*, name=None, src=None, dest=None, version=None):
    print("git_module", name)
    assert name != None, "git_module must have a name"
    assert src != None, "git_module must have a src"
    assert dest != None, "git_module must have a dest"
    assert version != None, "git_module must have a version"
    populate_git_module(src, dest, version)

with open("peru") as perufile:
    code = perufile.read()

exec(code, {"git_module" : git_module})
